<p> <html>   <head>     <meta name="viewport" content="width=device-width, initial-scale=1.0">     <style>       * {         box-sizing: border-box;       }       body {         width: 30em;         margin: auto;         font-size: 22px;         line-height: 1.5em;         overflow-wrap: break-word;         word-wrap: break-word;         hyphens: auto;       }       @media (max-width: 704px) {         body {           padding: 0 1em;           width: 100%;         }       }       ul li { 	margin: 0.75em 0;       }       ul li:first-of-type,       ul li:last-of-type { 	margin: 0;       }     </style>     <title>Pyzozord's Blog</title>   </head>   <body></p>

<h3>Mon  9 Nov 16:54:23 CET 2020</h3>

<p> I found yet another Mike Acton's talk, this time about Technical Direction. It's another great piece of advice how to be a good engineer. </p>

<p> Here is the full talk <a href="https://www.youtube.com/watch?v=WQlf9UIzF14">https://www.youtube.com/watch?v=WQlf9UIzF14</a></p>

<ul>
<li>Technical Direction management breaks down to 5 elements: cost, commitment, conflict and cooperation. We'll get context for each one of the five elements, specifically example, risk profile, hard for Mike, training.</li>
</ul>

<p> Examples</p>

<ul>
<li>Confidence: schedules are a tool to build confidence. Don't focus on managing a schedule, focus on the confidence. Where are you confident and not confident, and how can you change it.</li>
<li>Confidence: 80/50 rule, when you spent 50% resources and are not 80% done you are far behind.</li>
<li>Cost: you can't estimate cost of solving problems you haven't solved before, but it's not the cost that's the problem, it's the value. You should know how much development time is it worth solving first. If you don't know the worth, the cost is completely meaningless.</li>
<li>Cost: It's important to have a cost profile for Development vs Research. It's 80/20 for Mike at the time of the talk. Research are problems with unknown value or cost, it's exploration. </li>
<li>Cost: Development are problems have an expected return. It's important to have a rule of thumb. For example 1 day of development should yield 5 days return.</li>
<li>Cost: You always need to make decisions whether you should build or buy a solution so you should have a "function" to answer it. The "function" can be for example "can we create competitive advantage by knowing our context better then anyone else?".</li>
<li>Commitment: There are always lots of variables, so it's not an excuse. You need to just give your best guess.</li>
<li>Commitment: But you need to make internal calculation on where you can put down your risk. Work on increasing your confidence. </li>
<li>Commitment What would be the things you would be proud of to say you did in five years from now. </li>
<li>Commitment: Ramifications of choices aren't forever but last way longer then you think, it can hang around for 10 years on average.</li>
<li>Conflict: ask yourself how to not be like Uber (? some famous conflicts in uber in 2015-2017?).</li>
<li>Conflict: use processes to protect people from biases of the director. Example: lead developers can "outvote" the director.</li>
<li>Conflict: the director should represent the company values.</li>
<li>Conflict: if someone thinks there is a problem, there is a problem (at least a perception problem). Do not dismiss when people feel there is a problem.</li>
<li>Conflict: technical director needs to know what accountability means. Be prepared to accept the cost to fix mistakes that affect others.</li>
<li>Conflict: "conflict cockroaches" are hard to kill conflicts. Interpersonal fights or passive aggressive communication has to be stopped as soon as possible or it will only will get worse and will last even longer.</li>
<li>Cooperation: Surprise is bad. Things should be obvious, clear, and as boring as possible.</li>
<li>Cooperation: 80% of a project is "selling it", actual work is only 20%. Know what people say they want. Paint the picture for the future you're selling.</li>
<li>Cooperation: Quarterly road map. Every feature needs user-size champion.</li>
</ul>

<p> Risk profile</p>

<ul>
<li>Confidence: If you have too much confidence you are not doing anything interesting because you've done it before. Too little confidence is not getting anything done. Find the balance with R{{contents}}D profile. Move over confident people around to other areas. Gives them interesting thing to do and opens op a spot for someone else to do the first thing. Find things that we are always confident about and let's get them off the table.</li>
<li>Cost: spending too much is losing money, spending not enough is losing opportunity. To balance cost: triage, measure ux, ruthless editing (deciding on what to do or not to do). </li>
<li>Cost: is it worth to solve this problem. Prioritize. It's hard to say "no" and hear the "no".</li>
<li>Commitment: if you over-commit you will burn out, you will be long-term failure if not successful. If you under-commit nobody knows what you work on and can't work with you or will assume you will do everything they want. To balance apply constant steady pressure.</li>
<li>Commitment: teams drive commitments, they need to decide for themselves. But director should review and veto.</li>
<li>Commitment: director should always provide problem and value to solve, never solution.</li>
<li>Conflict: too much conflict is a toxic environment, not enough conflict means no creative energy because no critical review. To balance: survey the team as often as possible. Make sure the team is comfortable with reviewing inside the team. Unfiltered feedback firehouse, everyone can see it. </li>
<li>Cooperation: too much cooperation and you have a committee, not enough you have pieces that don't fit. To balance everyone practice leadership, everyone needs to be leading something. Work backwards from production schedule (yours and others).</li>
</ul>

<p> Hard for Mike</p>

<ul>
<li>Confidence: scale of communication. He wants everyone to be confident about what his team is doing but each person has to be talked to differently to get them confidence. He ensures that his leads need to know the messaging (delegation).</li>
<li>Confidence: if asked to talk about design, people say they don't have time, but when you say you are going to do react immediately. If you make commitments loud and early people are willing to talk about them.</li>
<li>Confidence: Ensure as much 1:1 as much as possible for the team but also for in other teams.</li>
<li>Cost: Subjective measure of value. How much is a millisecond worth specifically. How much is one person slightly less frustrated (by ux) worth?</li>
<li>Cost: to solve, send surveys. Try to turn subjective measure into objective measure. </li>
<li>Cost: Budget time for low hanging fruit and optimization</li>
<li>Commitment: Autonomy vs Management. Some people may self-burnout or over-commit. Get people to take time off. No heroism (no surprises). Language is important you are not request vacation, it was already yours; you did not do heroic job, you were forced to do it (because something went wrong). Implied promises and letting people know they might just implied somewhere.</li>
<li>Conflict: Mike's instinct is to "suck it up" but it's wrong. To solve for that, spend time to build trust. Don't say anything and check if the person is looking for advice first. Remember perception problems are real problems.</li>
<li>Cooperation: Timing. The next thing is always important thing ever (and it should be), but there is a limit. Stay out of the way of the next thing people are working on (demo, etc). Build reference targets, what it should look like. Have dedicated sources for immediate issues.</li>
</ul>

<p> Training</p>

<ul>
<li>Confidence: people need to know how to pitch. Pitch should paint the picture, include cost, value,opportunities to learn and a plan to transition (migration) to that change. </li>
<li>Cost: cost/value metrics. People should be able to point out: development cost, maintenance cost, cost of entry, efficiency return (if applicable), user value (if applicable), learning value.</li>
<li>Commitment: MVP, be clear and complete on what you are providing. "You will be able to do XXX" promise. Separate would-be-nice and guarantees.</li>
<li>Commitment: Articulate clearly but in user value. State concrete changes. State problem and part of the problem solved. Clear expectations (to make sure people are not not assume).</li>
<li>Conflict: Set expectations in terms of company values. It's not about changing their personality, but it's about being effective (communicate effective), and "what's right". The director's values are the values that are important to the team. Corporate neutrality is over.</li>
<li>Conflict: to set clear values: be able to say what you believe, feedback on how people met values during reviews and 1:1. Whenever there is conflict know who will take action after the conflict.</li>
<li>Cooperation: Convincing people to be champions of a solution. Find someone who will let you know if you managed to deliver thing you were championing.</li>
<li>Cooperation: championing should include: articulate how the change will affect the company or product, why the change is important to you personally and you need to know how to gather support. </li>
</ul>

<h3>Mon  9 Nov 12:41:32 CET 2020</h3>

<p> Mike Acton's advice on how to be a good engineer.</p>

<ul>
<li>It takes about 2 years for a company to be on net positive for a new programmer.</li>
</ul>

<p> Misconceptions:</p>

<ul>
<li>Single responsibility principle: piratically speaking is not true because there are lot's of things that are more efficient or make more sense or are the most common shared.</li>
<li>Don't reinvent the wheel: nonsense, reinvent the wheel to learn how it works and make adjustments. The reality is that world is not once size fits all.</li>
<li>Spend more time reading the writing code: it's not about "reading", it's about "understanding how and why it works".</li>
<li>You don't need to recode if you plan and design first: You will never going to have all requirements up front, people are constantly learning. Make the best decisions with the knowledge you have but don't assume new knowledge won't come.</li>
<li>Write in a way next programmer can understand it: Yes, but don't write code for idiots. You can safely assume the reader will be smart (you in the future).</li>
<li>Abstraction is good: Engineers are working in reality and are constrained by real life limits of hardware and other requirements. </li>
<li>Programmers shouldn't worry about memory: Memory is the most important resource in computer system. Retrieving memory is by far the slowest operation in total.</li>
<li>The compiler is your friend: It is a tool, You are responsible for what compiler outputs. So you need to be an expert in your tool.</li>
<li>Premature optimization is the root of all evil: Don't write optimized code but think about it ahead of time. If you don't think about optimization when it becomes a problem it is too late to fix it. You don't need to write optimized code from the start but you need to know how you will write it later.</li>
<li>O notation: it's misleading, often O(1) maybe slower then O(n).</li>
</ul>

<p> Technical skills:</p>

<ul>
<li>Technical skills you should have: understanding how OS, CPU, (GPU), memory bus work. Experience with SIMD instructions. Being able to read and write assembly fluently. Actively researching some area of expertise.</li>
<li>Aside of technical skills people are essentially incompetent in three essential areas: practice, reasonable defaults, problem solving. None of these are very hard.</li>
</ul>

<p> Practice: </p>

<ul>
<li>Explore gaps in your knowledge.</li>
<li>It's ephemeral, you are not building a project or researching things.</li>
<li>The purpose of practice is to practice and get better.</li>
<li>It's not competitive. </li>
<li>You should do at least 30 minutes every day.</li>
<li>Remember to throw away the result and try again next day from scratch.</li>
<li>For example try every day be 30 minutes writing an application. Ever day start from scratch. After 30 days you will be able to write much more in 30 minutes.</li>
</ul>

<p> Reasonable defaults: </p>

<ul>
<li>Linear search through the array is almost always the (good enough or even the best) answer. </li>
<li>FIFO managed by incremented integer and Index Look-aside Table are two extremely common and important data structures</li>
<li>code for that first. Don't think of objects in the vacuum, most of the time there are many of the same thing. Explicit latency and throughput: how long it takes and when should be able to issue new command. It should be explicit, written down and part of the design. Always version your serialized version. Have simple allocators: block, stack and scratch allocators. That's all you need 90% of the time. Model your target manually first (cheat): do quick and dirty prototypes, get to provable prototype by any means necessary as fast as possible. </li>
</ul>

<p> Problem solving: </p>

<ul>
<li>the most shocking and the biggest issue, and it's not a technical skill. </li>
<li>It's "I can't reason about solving the problem".</li>
<li>Solving problem is an iterative process. You should keep looping those things to approach solving.</li>
<li>Steps of problem solving: 1) context, 2) value, 3) cost, 4) platform, 5) data.</li>
<li>As we iterate we always learn new things, write it down.As we learn new information during the process</li>
</ul>

<p> Problem solving Step 1: Context</p>

<ul>
<li>It's all things that can be assumed to be known. The more context you have the better you can solve the problem. </li>
<li>Programmers fall into making things too generic and basically invent a compiler so they can avoid solving the actual problem. That only adds a new problem. </li>
<li>It is easier to solve problems with context then in generic space. </li>
<li>Different problems require different solutions. Don't fit solutions into problems. Don't ask which one of the design patterns works here. "find" solution to a problem, don't "fit" solution to a problem. If something fundamental changes about the problem, then it's a different problem and the solution is different.</li>
<li>Identify what the user needs are. You can watch your users work, what data they are transforming (using).</li>
<li>Describe concrete goals in plain language. You are not writing generic features, you are writing solutions for real problems of real humans.</li>
<li>Identify and balance constraints. Find out the actual constraint. For example when working is it OK if you take 5 min to finish it? And 5 years? Where is the limit then? Same with software size, speed etc.</li>
<li>Iteration. How long can this take to still be useful. Maybe not articulated, is something acceptable in 2 minutes? And 2 years? Then where is the line exactly?</li>
<li>Learning. Research problem is not a production problem. They should be treated separately.</li>
<li>Write down the constraints/limits.</li>
<li>Nothing is perfectly correct. We accept certain amount of incorrectness. What is the level of accessibility. How many find-able bugs are acceptable.</li>
</ul>

<p> Context traps</p>

<ul>
<li>The what-if game. If we are actually trying to cover that case then lets stop and make design decision about that. If we don't know if that is the case, then what are the chances that is the case. Make decisions based on the imperfect knowledge (e.g. 20% chance some case needs to be cover). Never create a thing that does all the things all the time. If people play what-if game ask practical questions: "do you have concrete example?", "how common would it be?", "can you test for it?", "how much experience do you have with the problem, or are you just making the stuff up?". Solving problems you don't have creates problems you do have.</li>
<li>Future proofing is fools' errand. Things change quickly. Every two decades things change radically. Find the lifetime of your project. Ask yourself if you feel comfortable delete it after lifespan? If you don't feel comfortable, maybe you should extend the lifespan. The future is unknowable. </li>
<li>You (engineer who researches and practices) will be much better in 5 years, so solve the problem with knowledge you have and accept that you will solve next problem better.</li>
<li>People are creative and will find a way to work with constraints. Often the constraints will actually they can actually use the constraint of the system.</li>
<li>Do not conceptually oversimplify a problem. You can't make problem simpler then it is. There are real variables that can't just abstract away. Abstractions are not leaky, this is how reality works.</li>
<li>If people are hacking in your system, the problem is your system not the hacks. You were trying to over-abstract or oversimplify or problem has changed over time.</li>
<li>Spend the time to examine and analyze the data. Where is it coming from, what is the entire workflow, like build time and run time. Entire workflow all the way back to the source.</li>
<li>You can't oversimplify a problem and do it in a bubble. Things have dependencies. Understand those dependencies.</li>
<li>Do not ignore the You have hard and complicated problems. Try to organize and manage the data but do not ignore the data, do not oversimplify. If you ignore problems you just make it more complicated.</li>
<li>Do not over-complicate problems. Often programmers overgeneralize and effectively try to create a compiler without context. You should solve problems with as much context as possible.</li>
<li>Do not create "stories" solve problems at hand. Stories require extra consistency for the sake of the story itself.</li>
<li>Your job as engineer is to actually solve the actual problem, do not use generic as excuse to not understanding and using the context.</li>
</ul>

<p> Problem solving Step 2: Value</p>

<ul>
<li>Identify the value, in real life terms, Is it worth 2 weeks of my time to solve it. Is it worth 10 years? Where is the exact limit? </li>
<li>When you know how much time you have to solve the problem you can make decisions to fit in that time. </li>
<li>Organize your time.</li>
<li>Breaking down business case for the feature. Why are we doing the feature.</li>
<li>Selling feature to your lead or team and getting everybody on board is massive part of the job of professional programmer.</li>
<li>Articulate targets, how much iteration time are we saving, how much one man-month is worth. What are you treading off. What is the cost.</li>
</ul>

<p> Problem solving Step 3: Cost</p>

<ul>
<li>Predicted development time is generally wrong. Can correct only for things that you have already done. But if you work from a time limit you can engineer a solution that fits in that limit. You start with Plan B to have something working if everything else fails.</li>
<li>What is the opportunity cost. Any time you spend means it's time that is not time spend somewhere else. Need to be aware of that.</li>
<li>Maintenance cost is real time that all developers pay. How can you minimize it or eliminate it.</li>
<li>If you can reason about maintenance cost you spend resources you don't have. You will spend time fixing buys you haven't accounted for. </li>
<li>Sources of maintenance: maintain understanding of data changing over time, changing requirements, constraints/limits changed, untested data transformations, unexpected use-cases, dependency changes, bad inputs, usage training, infrastructure/platform changes, any change whatsoever. If you make any change to the system, there is high chance another bug will appear. You stop bugs incoming to the system when you stop working on the system.</li>
<li>Build vs Buy. How well can reason about value vs cost. Stop with the "feelings" and start with the "reason" (so use actual data information). Write it down, apply process.</li>
<li>Reality is not a hack you need to deal with to solve your abstract, theoretical problem. Reality is the actual problem.</li>
</ul>

<p> Problem solving Step 4: Platform</p>

<ul>
<li>No such thing as "platform independent"</li>
<li>RTFM especially x64 and arm. Also nvidia, ati, opengl, opengl es, vulkan, directx 11, windows, linux.</li>
<li>You can't abstract these things away but you can organize commonalities.</li>
<li>You can't abstract fact that resources are shared. It is a reality you must deal with. Especially caches, RAM, HDD, BDD, network.</li>
<li>Know your tools, you are responsible for the output of your tools. Do you understand how it works, can you change how it works and what it outputs. Any tool that gets in a way of you from understanding how it works is a bad tool.</li>
</ul>

<p> Problem solving Step 5: Data</p>

<ul>
<li>Everything is data problem.</li>
<li>All programs just transform data. If you don't understand data you don't understand the problem and you can't design right solution. </li>
<li>What are the data limits, what is the count, range, what is likelihood of appearing over time statistically, how is it going to be organized statistically.</li>
<li>Gather your data to understand it.</li>
<li>Sample input and output data over time. You can analyze it offline</li>
<li>Visualize your data in as many ways as you can. 3D graphs, excel, transform data in a script.</li>
<li>Know what was read and written over time. What access patterns look like over time statistically. When data is accessed statistically relative to other data. What values are most common. What are the outliers. What ranges are common. What causes branches and how likely is it statistically.</li>
<li>You have inside and outside of your program. You should have both. You should have ephemeral tools that live to just look at specific data. There are no good generic tools to analyze data.</li>
<li>Remove unnecessary work. Stop doing the stupid things that have no reason. Only solve the problem at hand.</li>
</ul>

<h3>Mon  9 Nov 11:11:19 CET 2020</h3>

<p> Mike Acton's advice on how to be a professional programmer. Unsurprisingly there is a lot of overlap with the advice from the Passionate Programmer by Chad Fowler which I find reassuring, since I wasn't 100% convinced to the Chad's book.</p>

<p> Mike has a 25 minutes talk on GDC with sentences he believes a good professional programmer should answer "yes" to. He goes into some detail on each sentence, but I believe they are mostly self explanatory.</p>

<p> You can watch the original talk here: <a href="https://www.youtube.com/watch?v=cV5HArLYajE">https://www.youtube.com/watch?v=cV5HArLYajE</a></p>

<p> I organized all points into two categories: a professional, an a programmer because I feel the first category is more broad and can apply to other professions as well.</p>

<p> A professional</p>

<ul>
<li>"I can articulate precisely what problem I am trying to solve" </li>
<li>"I have actually articulated what problem I am trying to solve"</li>
<li>"I have confirmed that someone else can articulate what problem I am trying solve"</li>
<li>"I can articulate why my problem is important to solve"</li>
<li>"I can articulate how much [of my work time] is my problem worth solving"</li>
<li>"I have a Plan B in case my solution to my current problem doesn't work"</li>
<li>"I have already implemented my Plan B in case my solution to my current problem doesn't work"</li>
<li>"I can articulate the steps required to solve my current problem"</li>
<li>"I can clearly articulate unknowns and risks associated with my current problem"</li>
<li>"I have not thought or said "I can just make up the time" without immediately talking to someone"</li>
<li>"I can schedule my own time well"</li>
<li>"I am vigilant about not wasting other's time"</li>
<li>"I actively seek constructive feedback and take it seriously"</li>
<li>"I am not actively avoiding any uncomfortable (professional) conversations"</li>
<li>"I am not actively avoiding any (professional) conflicts"</li>
<li>"I consistently interact with other professionals, professionally"</li>
<li>"I can articulate what I believe others should expect from me"</li>
<li>"I don't require multiple reminders to respond to a request or complete work"</li>
<li>"I pursue opportunities to return value of the commons (when appropriate)"</li>
<li>"I actively work to bring value to the people I work with"</li>
<li>"I actively work to ensure underrepresented voices are heard"</li>
</ul>

<p> A programmer</p>

<ul>
<li>"I have sat and watched an actual user of my system"</li>
<li>"I write a "framework" and have used it multiple times to actually solve a problem it was intended to solve"</li>
<li>"I can articulate the test for completion of my current problem is"</li>
<li>"I can articulate the hypothesis related to my problem and how I could falsify it"</li>
<li>"I can articulate the most common concrete use-case of the system I am developing"</li>
<li>"I know the most common actual, real-life values of the data I am transforming"</li>
<li>"I can articulate what will happen when (somehow) data outside that range enters the system"</li>
<li>"I can articulate a list of input data into my system roughly sorted by likelihood"</li>
<li>"I know the frequency of change of the actual, real-life values of the data I am transforming"</li>
<li>"I know the slowest part of the users of my system's workflow with high confidence"</li>
<li>"I know what information users of my system will need to make effective use of the solution"</li>
<li>"I can articulate the finite set of hardware I am designing my solution to work for"</li>
<li>"I can articulate how that set of hardware specifically affects the design of my system"</li>
<li>"I know how to significantly improve the performance of my system without changing the input/output interface of the system"</li>
<li>"I know what data I am reading as part of my solution and where it comes from"</li>
<li>"I know how often I am reading data I do not need as part of my solution"</li>
<li>"I know what data I am reading as part of my solution and where it is used"</li>
<li>"I know how often I am writing data I do not need to as part of my solution"</li>
<li>"I can articulate how all the data I use is laid out in memory"</li>
<li>"I can articulate the (various) latency requirements for my current problem"</li>
<li>"I can articulate the (various) throughput requirements for my current problem"</li>
<li>"I have (at least partially) read the (available) documentation for the hardware, platform and tools I use the most commonly"</li>
<li>"I have recently profiled the performance of my system"</li>
<li>"I have recently profiled memory usage of my system"</li>
<li>"I have used multiple different profiling methods to measure the performance of my system"</li>
<li>"I know specifically how I can and will debug live release builds of my work when they fail"</li>
<li>"I never use the phrase "platform independent" when referring to my work"</li>
<li>"I never use the phrase "future proof" when referring to my work"</li>
</ul>

<p> I've scored myself answer "no" to all sentences I can use more practice or, so I believe it was a pretty harsh judgment on myself, anyhow I got somewhere around 15-25 points.</p>

<p> Funny thing is, that there is only 49 questions yet in his scoring system Mike pranks us because only scores of 50 are not fired from his hypothetical example company. I believe what he is trying to say is that "you need to do more then those 49 things".</p>

<h3>Mon  9 Nov 10:42:59 CET 2020</h3>

<p> I've spent recently some time learning fundamentals of CMAKE and started building my first rogue-like game. That was a very exciting experience. I realize I am in a "honeymoon" period with gamedev but the feeling of making a game was more then I ever dreamed of. I felt like I've finally found my calling. This is definitely how I see my (hopefully) early retirement - making games.</p>

<p> Having done a basic map, a controllable character and even a vision and path-finding systems functioning (thanks to the libtcod library) I started scheming out few concepts for how I want to organize my game world. I eventually stumbled upon Pure Entity Component System design pattern and Data Oriented Design approach to programming, and among other great people I listened to what Jon Blow (Braid and The Witness), Casey Muratori (Handmade Hero) and finally Mike Acton (Unity3D's engine team lead designer) have to say on the subject. They all seem to say similar things, but Mike's talks are the most concrete and comprehensive. Over the next few posts I'll make a short summary of what I learned from Mike.</p>

<h3>Sat 31 Oct 09:08:32 CET 2020</h3>

<h4>The Passionate Programmer by Chad Fowler (ISBN 1-934356-34-4).</h4>

<p> To be completely honest, I have mixed feelings about this book. I don't necessarily agree with some of the opinions and perspectives expressed in this book, however I do recognize that all of the advises given will be effective if one's goal is to keep current job or get promoted. On the other hand I subscribe under some other opinions with both hands and a leg.</p>

<p> It's a light book and can be read in just a few evenings. It has some interesting stories and good advises but I felt like a lot of the material is obvious. It seems like there are two distinct target audiences for this book: people who are afraid to lose their current job, and people who want to be the best professional; and perhaps some gradient in between. I fall more into the second category, and that is why I original picked up this book. Nonetheless some advises were really good, some helped me organize my preexisting thoughts on the subject and some were fresh and expanded my perspective.</p>

<p> I'll ignore the parts I didn't agree with, or felt uncomfortable with. They had more to do with the goal behind the actions, the motivation, rather then the actions themselves which I found to be sound advises given the assumption for reader's goal was accurate.</p>

<p> I'll write down below my notes and TLDRs to solidify the fresh knowledge and as a future reference if I ever need to remind myself some of those points.</p>

<p> Part 1: "Lead or Bleed?"</p>

<ul>
<li> "Supply and Demand". Be aware of what skills are or will be in high and low demand and high and low supply. Take advantage of market imbalances. Old technologies, new technologies, don't just follow what is popular do the research about the market.</li>
<li> "Coding Don't cut it Anymore" - You are not just a coder. You were hired to generate capital for the business, make it so. Understand business. Talk to the business in business language. Do everything you can to help the business.</li>
<li> "Be the Worst". You level up to your environment (up or down). Talented people will make you better at your job just by proximity and the level of the conversation. And vice versa, you'll lose some skill if you get used to a lower level.</li>
<li> "Invest in Your Intelligence". Recognize your knowledge gaps and other blind spots, and actively work to improve in those areas. Choose technologies from opposite camps and learn them.</li>
<li> "Don't Listen to Your Parents". Take risks, be conscious of your decisions and what possible fears have driven them, and what would be the decision if fear wasn't a factor.</li>
<li> "Be a Generalist". Understand a bit of all technologies and the full stack; (also business subjects). Be able to solve problems in multiple connected fields and in between them. Problems are often "between" fields. Be the "problem solver" of your team/company especially for problems other people can't solve. Make your self useful any way you can, don't be "just" a [job description]. Your skills should transcend technology platforms.</li>
<li>"Be a Specialist". Specializing in something doesn't mean not knowing about other things. Do you know how to crash your language's vm? What if specialist surgeon didn't know why the machine over there started beeping? Specialists have deep knowledge and experience. Understand deeply everything that involves your technology (like vm, os, etc). Start teaching those aspects of technology. Being a mentor is one of the best ways to learn.</li>
<li>"Don't Put All Your Eggs in Someone Else's Basket".  Don't be a Java(Script) specialist, a Microsoft Word designer. Technologies and companies go obsolete. Your career is your Business. Vendor-centric views are myopic. Try doing stuff in competing technologies.</li>
<li>"Love It or Leave It". Seriously. You can fake it for a while but a lack of passion will catch up with you. Monitor how passionate you are, write a log.</li>
</ul>

<p> Part 2: "Investing in Your Product"</p>

<ul>
<li>"Learn to Fish". Don't be at the mercy of other people, learn it for yourself, be self sufficient. Do you understand everything that is being done for you by tools, generators, applications and other people? Dig deep - "why and how does this work", stop only when you don't know how to dig deeper. Pick most neglected tools or skills you use and drill on them (git, bash etc).</li>
<li>"Learn How Businesses Really Work". Don't get bored on the business meetings. Understand why they happen and what is happening. Understand how is your company working and is profitable. Context is very important. What is a bottom line, and how do you contribute to it? Read an MBA book.</li>
<li>"Find a Mentor". It's OK to depend on someone, but find the right person. Be an apprentice. Mentor helps navigate infinite space of possible things to learn and provide useful feedback. It's also useful to know someone experiences. Self mentor, learn from people in the field you admire. Analyze their qualities, compare against yours, you got a list of things to do better.</li>
<li>"Be a Mentor". You understand things well only if you can explain them. Great way to learn is to teach. Also a social benefit of knowing people may come in useful. Also in non-traditional forms like mailing list, IRC, etc.</li>
<li>"Practice, Practice, Practice". Practice is where you are out of comfort zone. Good practice is when it feels awkward and difficult. Your code has to come out ugly. You should improve over time, then practice on the further awkward zone. Open source is great place to practice, community feedback will be valuable. Give yourself constraints, don't use X, or do it in Y time, etc. Make it feel challenging. Practice reading and writing (physically), understand threads, regexps, streams, other basic stuff, often not well understood stuff. Use online programming challenges (hackerrank? project euler?).</li>
<li>"The Way That You Do It". Learn methodologies and software processes. Help improve your company's. Put together a plan, get buy-ins from others. If can't change the process, understand and make the best out of the imposed process.</li>
<li>"On the Shoulders of Giants". Read great code! Learn from it! Compare it with your code. Keep adding tools and tricks to your bag, notice habits. Also helps you discover what is already out there, so you don't need to reinvent. There is much to be learn from people who came before us. Read projects like books, make notes. Write critique, publish it. Find a book club for code.</li>
<li>"Automate Yourself into a Job". Build habit of noticing repetitive tasks. Make automations. Code generators and other things. Don't worry about things other then just saving time. Learn about Model Driven Architecture.</li>
</ul>

<p> Part 3: "Executing"</p>

<ul>
<li>"Right Now". What can you do right now? Don't get comfortable. Self of urgency is increases productivity. Recognize the unproductive periods and improve. Turn long many month projects into short week projects. Release right now, things will come up that wouldn't come up otherwise.</li>
<li>"Mind reader". Do things you assume others will need or are bothered by or express would want be "magically" done. It's a gamble. Do only small things, avoid things that lock in decisions/architectures. Do it to help and impress. Track hit rate with your guesses.</li>
<li>"Daily Hit". Report at least one accomplishment every day. Make sure your manager knows. Track daily hits, set goals daily, weekly or longer. Think of business value. Done well becomes a habit - no tracking needed. What are annoying things for the team and no one fixes it? What can be automated? Try to do one per day. Win peoples hearts.</li>
<li>"Remember Who You Work For". Understand company goals and metrics. Make change, change yourself, your team, your department and your company to help achieve the goals. Solve problems for your managers. That's your job, you do the work. He will take credit, but he also praises you. Ask your manager how can you make a difference. Then evaluate with him next time.</li>
<li>"Be Where You're At". Accept your current role. Be ambitious but don't rub in the face of everyone. Don't cherry-pick work, and don't do sloppy job at the grunt work. The feeling of not being at position you deserve will never end, the cycle repeats. Keep focused on the present, it will get you further. You will feel happier and it will show. Talk about work goals avoid career subjects, office politics and gossip.</li>
<li>"How Good a Job Can I Do Today?". Make more fun jobs you chose not to give full effort. Try to give your full effort all the time. Add challenge to the boring stuff. Maybe a scoreboard for unit test coverage for friendly competition with coworkers for bragging rights or prizes?</li>
<li>"How Much Are You Worth?". Your employer pays for you twice your salary. Make yourself worth the investment. How much is that per day? Were you worth it today?</li>
<li>"A Pebble in a Bucket of Water". Humility is important. Company will go on without you. Make yourself as replaceable as possible, it will make better environment, also easier to move on for you if necessary. Be aware of parts of code where team depends on you, and make sure they don't. Write documentation, refactor, explain.</li>
<li>"Learn to Love Maintenance". Maintenance can be creative and unrestricted. There is not as much expectations as with greenfield projects. How much faster, more elegant and simpler can this part of the code be? Adding well placed bells and whistles where unexpected will win minds and hearts. Interacting with customer, enables you to truly learn how your business works. Greenfield projects are maintenance as soon as first line of code is written. Build ways to measure, pick important metrics and improve the product.</li>
<li>"Eight-Hour Buron". Work so relentlessly after 8 hours you couldn't continue. Make your time as efficient as possible. Be very mindful of your time during work, manage it like a resource. When we have more of a resource we are more careless about it. Work less, accomplish more. Make sure you rest well.</li>
<li>"Learn How to Fail". Humans make mistakes. Don't gag errors, use asserts during development. Errors are information. Too much defensive programming makes you blind. But it's also important to handle unforeseen errors. Everybody makes mistakes, so people don't judge each other by mistakes too much but rather by how we deal with those mistakes. Raise issues early, sooner found sooner gone. Take the blame, don't discuss blame, just get it fix asap. Offer solution or plan to find solution. Talk about concrete things, and time frames. Ask for help, it's all just about the problem being fixed. Stressful times are the best times to build loyalty. Well handled mistakes are better then no mistakes.</li>
<li>"Say No". When manager asks if something can be done, it's probably for the reason. Ask for the concrete reason, maybe someone asked him. It's often not arbitrary. People who say yes all the time are geniuses or are laying. If you can't say "yes", say "I don't know, I need time to check" or "I don't know but will do my best". Insecure people don't say "I don't know". Record your commitments and results.</li>
<li>"Don't Panic". None of the disasters/emergencies had noticeable impact on your career. Panicking is decreasing your performance and decision making. Good mechanism for survival, not good for software development. Keep panic journal, helps you recognize the situations after and improve at recognizing the situations as they happen.</li>
<li>"Say It, Do It, Show It". Commit to your plan. Plans can be short. Find things to do and prioritize, be realistic. Do daily plans. Mark tasks done, it's a nice feeling. By rhythmic. Then make bigger plans, week, month... Communicate your plans to your management, they love it. Keep it transparent or people will stop trusting your plans. Solid plan can convince people.</li>
</ul>

<p> Part 4: "Marketing... Not Just for Suits"</p>

<ul>
<li>"Perceptions, Perschmeptions". You should care what other people think of you. If you do great job and no one sees then no one cares. Performance appraisal is always subjective, there is no objective way to review performance. You will be measured on someone's perception. Different groups will care about different things. Manager your communication skills, colleagues your technical skills.</li>
<li>"Adventure Tour Guide". Customers and manager are forced to relay on you, they are afraid of you and look for people who will make them comfortable. They are probably just as smart as you or smarter but know different things. Reverse the perspective, be a guest in their world. They are an expert helping you get your job done. Customer, sales, managers will be your advocates about promotions and firing. Are you grumpy? Are they afraid of you or telling you? Find situations where you are the non-expert. How would you like the expert to treat you?</li>
<li>"Me Rite Reel Nice". Communicate well. Expand your vocabulary. Communicate ideas elegantly and precisely in a simple way so they are easy to understand. If you can't explain it easy in English, you cannot explain it easy in code. Keep a diary, practice writing and explaining. Learn touch-typing.</li>
<li>"Be Present".  "Out of sight, out of mind". Do no be out of mind. Face-to-face communication creates tighter personal bonds. Important decisions are made over coffee or side conversations. Most people like interacting with other people in person. Learn about your colleagues, be personal. Ask sometimes "how are you today?" or "what do you do on weekends generally?", try to learn about the people. They will be more understanding of your mistakes. Reach out to people you don't have enough contact with regularly (make a reminder).</li>
<li>"Suit Speak". Talk to business people in terms of business language, not computer language. How does your accomplishment relate to the business? How does it benefit the company?</li>
<li>"Change the World". You need to have a mission to visibly change your team and company. Change can be small like more unit tests, not methodology or technology. You need to be driven to do your mission intrinsically. Some people will get angry, that's OK as long as your intentions are right. Don't be a jerk but also don't be sorry. Find your personal crusade. Don't be a zealot.</li>
<li>"Let Your Voice Be Heard". Write a book, publish articles, present on conferences. Cool by association. Network. Don't limit yourself to the company you are working for. Participate in communities offline and online. You do have something to teach, and you will never feel 100% ready.</li>
<li>"Build Your Brand". Your name is your brand. Don't water down what you stand for, be careful where you let your name show up. Don't send lousy messages or emails to many people. Don't be a jerk. Protect your brand from yourself.</li>
<li>"Release Your code". Ask if you can open source parts of the code. Contribute to famous one source projects. It's a demonstrable skill. You can for example find what part of open source project is not well covered in unit tests. Refactor it to be easily coverable and cover it in tests.</li>
<li>"Remarkability". Doesn't necessarily means "good", but does mean "worthy of attention". Not the cow with the best milk, the purple cow. Just stand out. Master a subject and write a book on it. Write code generator that reduces a week long task in to 5 minutes. Do something big and unthinkable on your next project. Be the purple cow who gives the best milk. Notice what other people "remark".</li>
<li>"Making the Hang". Don't be afraid to hang around the pros. All it takes to make a connection is a little less humility. "Be the worst" one in the group. Don't be afraid to reach out to real pros. Also local ones. Go out of your way to make a conversations, especially if it makes you uncomfortable.</li>
</ul>

<p> Part 5: "Maintaining Your Edge"</p>

<ul>
<li>"Already Obsolete". Technology moves really fast (most times). Start thinking ahead. It's gamble but you will lose if you don't play anyway. Keep your hand on the pulse of bleeding edge tech. Try it out. Make reminders.</li>
<li>"You've Already Lost Your Job". Things are changing, economy is shifting, business is moving on. Don't limit yourself to your job description. Do not identify as your job. Try different jobs like tester or manager or other.</li>
<li>"Path with No Destination". After each goal is next. The work is the goal. Focusing on the end makes you forget to improve the process. Bad process makes bad products, bad products make bad process. Try to enjoy washing the dishes.</li>
<li>"Make Yourself a Map". Make product features as markers to know you are moving forward. Features need to be cohesive. You are your own product, be cohesive. It's OK to diversify but it's good to have a story that keeps it all together and makes sense. Make a map list things you did, learn from them then make plans for the future.</li>
<li>"Watch the Market". Knowledge investment is like market investment, a gamble. If you stay comfortable with current skill sets you may miss next big thing. Watch "alpha geeks", often what they are into becomes the big thing tomorrow. Try becoming "alpha geek" or at least "make hang" with one.</li>
<li>"That Fat Man in the Mirror". The author is fat (the author of the book too). Do 360 reviews of yourself, take note of the blind spots. Ask for feedback and self evaluate regularly. Make reminders. Don't ignore HR reviews as nonsense, use them. Ask trustworthy people for feedback. List characteristics you think are important, make a questionnaire from it. Ask people to answer it. Keep a journal. Read old entries. How much have you changed?</li>
<li>"The South Indian Monkey Trap". Learn to let go. Rigid values make you fragile. Don't be a zealot about technologies, they come and go. Different technologies are best for different things. They may become obsolete over time unnoticed. Review your rigid believes and values. Explore things you hate (like technologies, do a project with it).</li>
<li>"Avoid Waterfall Career Planning". Do agile career planning instead. If you do waterfall you might realize you are getting career you wanted but no longer want. Course correct and change career if necessary.</li>
<li>"Better Than Yesterday". Overwhelming complexity is demotivating and can make it hard to see progress. Don't compare outcome, compare relative input instead. Make small improvements incrementally. Start small, the important thing is to keep doing it tomorrow. Make a list of things you want to improve. What can you do today about each item? Look at that list tomorrow. What can you do better this time? Do it again and again.</li>
<li>"Go Independent". The biggest challenge is to do it all yourself and not hide behind the comfortable chairs in a corporate office. In corporations responsibility is shared so much you can get by without doing much or being motivated. If you strive to be remarkable, big company is a difficult place to get the best out of yourself. Going independent will require you to give your best in all areas.</li>
</ul>

<h3>Fri 30 Oct 16:44:13 CET 2020</h3>

<p> I'll be preparing short articles about the two books I just finished: The C Programming Language by Kernighan and Ritchie and The Passionate Programmer by Fowler but in the mean time...</p>

<p> I just finally figured out how to use aspell, and thusly added <code>make spell-all</code> command to my blog and reviewed and corrected all posts so far.</p>

<h3>Fri  9 Oct 13:30:25 CEST 2020</h3>

<p> The VIP error turns out to be another case of REG_STARTEND flag bsd extension a for regexec() in ex/ex_subst.c in s() function responsible for the :s command. Same issue  as the last time with searching. This is aftermath of migrating to TRE which doesn't  support bsd's extensions. I noticed one more case of the same flag in ex/ex_global.c won't fix it for now since I haven't encountered that issue yet, but should be pretty straightforward to fix it. Vip is getting better and I am getting better at making it better.</p>

<h3>Fri  9 Oct 08:40:17 CEST 2020</h3>

<p> First to get it off my mind: I discovered another bug in VIP. I'm not exactly sure when it happens but it seems to happen if I use \$ in substitution command like so :s/$/./ on any line. Hopefully I can get it fixed today.</p>

<p> Now, for the main course. I have been considering going offline, or rather fantasizing about going offline for years now. The constant noise and addictive nature of social media, especially youtube.com and 9gag.com in my case make it almost impossible to be bored. I strongly believe being bored at least a bit is healthy. It creates space for you to think, helps with the feeling of being  under constant pressure and the "racing mind" syndrome. It forces you to plan just a bit which in turn teaches you to not just react immediately on your impulses. I knew about some of those effects before trying to go offline. After two days of limiting my access to internet I learned some of those other effects and ecstatic!</p>

<p> I was chatting on IRC about the golden era of computing the 70s and 80s and about how many things I hold dear were discovered at that time. Most defining computer science ideas, my favor game of all time Dungeons & Dragons. There was no easy access to internet and people were reading magazines. Kids were typing in code for the games from magazine into to Commodore 64 (or ZX Sepctrum  in Europe). That just sounds amazing to me. People who experienced that are  often saying that now is better and they would trade basic and magazine games for  google any day. They keep saying how information was scarce and in retrospective  it was a dark era. I think it's easy for them to say, they were brought up in  that era, they did not have a chance to build bad habits about constant access to  information.</p>

<p> Anyway, the subject moved on and I explained that I feel addicted to internet  and don't have enough self discipline to turn it off. One person suggested I  should just block the websites I don't like.  It's an amazing idea. Why did I not think about that before? I was only thinking about absolutely cutting off access  to all of the internet, but in reality most of my time is spent on just a handful  of website, and really non https internet usage is negligible, virtually  nonexistent. So this idea is great. I decided to implement it right away. That  was two days ago.</p>

<p>  I experimented with blocking urls on my ISP's router but it seems to not work  for some websites. One thing that came in useful from the router settings is  that I limited time when my laptop has access to internet. I set it to 09-17  every day. This has already shown an amazing break in habit. For the particular  websites I first tried adding those domains to /etc/hosts however I quickly  realized some websites have multiple top level domains like .com .co.uk .nl  etc., especially google.com which I decided to block as well. Yes it seems to  shock some people but I decided to kill completely access to google.com bing.com  and duckduckgo.com. I am now using as my main and only search Wikipedia. Yes  you are reading it right, Wikipedia. And for programming questions I use  stackexchange.com. It takes a bit of adjustment, but really not as much as you  would think. It also breaks another bad habit and forces me to read more  official documentations. To implement this revolutionary idea I reached out for  help on IRC and few moments later started my journey on writing my first my  first NSS module. I present to you <a href="https://github.com/pyzozord/rehosts">Rehosts</a>. It's like /etc/hosts file but allows for regular expressions. This is amazing, I have no idea why none else  did it before. I remember multiple times I wished I could use regexp in  /etc/hosts.</p>

<p> This post turned out way bigger then I expected so I'll have to write another one with the technical explanation of how does that NSS module work. This is actually first time for me writing an extension to an operating system, and I'm really proud of myself.</p>

<h3>Sun  4 Oct 10:39:19 CEST 2020</h3>

<p> Amazing! Yesterday I decided to have another stab at the VIP's db error. After debugging and reading some db5 documentation I randomly stumbled up the solution. The bug is now fixed marking VIP as a fully usable vi. I'll describe the bug again and it's solution for future reference.</p>

<p> Bug: After deleting a line or multiple lines such that the resulting file has less lines in total the undo command that would bring back those deleted lines error-ed and did not bring back those deleted lines.</p>

<p> Analysis: The symptom of the the underlying issue was a db error "BDB0063 DB_BUFFER_SMALL: User memory too small for return value" which was happening during append() which was called when bringing back those deleted lines. From what I understand after reading the documentation for DBC->put() (in the code it's DBC->c_put(), the name of the function changed in db5 but the legacy db4 naming still works) this "DB_BUFFER_SMALL" error indicates that we couldn't load the data from the database back to the memory because allocated memory is too small. </p>

<p> Fix: Changing the key's flag to DB_DBT_MALLOCK informs db that it should allocate enough memory for us. I assume that was the default behavior in db3 and now in db5 has to be explicitly stated. This fix can potentially be introducing new memory leaks, however I'm not sure at the moment. I'll need to put the entire program through valgrind anyway.</p>

<h3>Mon 14 Sep 14:47:16 CEST 2020</h3>

<p> Just a quick update. I temporarily suspended my C education. I went as far as the exercise 5-17 from K&R and I really enjoyed it. I certainly plan to come back to that and finish the book. However currently I feel I need to educate myself with the fundamentals of computer science, particularly algorithms, system design and other interesting, useful but ultimately never in Patrice used skills that are necessary to prove oneself during a job interview... My attitude probably shows that I have mixed feelings about this. On one hand those subjects are fascinating on the other I'm not especially happy to be so rudely interrupted during my C education.</p>

<h3>Fri 21 Aug 15:16:08 CEST 2020</h3>

<p> First of all I just discovered that my blog is capable of producing "&", I just need to add a backslash for escape. I must have foreseen this problem and implemented the escape sequence preemptively and had forgotten about it. It's a great feeling when you can thank your past self for being nice to you. ;)</p>

<p> I might change this behavior though, & is a common character in normal text. I should probably choose something more obscure for the template variable syntax instead, I won't use those things as much as & in normal text.</p>

<p> Anyhow,</p>

<p> recently I have been "relearning" C. I am making my way through the <a href="https://en.wikipedia.org/wiki/The_C_Programming_Language">K&R</a>. I'm currently close the end of the second chapter. I've been also using the <a href="http://www.iso-9899.info/wiki/Main_Page">##c homepage</a>, it's a great collection of resources! </p>

<p> This has been a extremely educative experience so far. Going slowly and methodically through all the boring details and drilling down on them let me discover new things I had no idea about.</p>

<ol>
<li> Getting familiar with the standard library</li>
<li> Endianness</li>
<li> Integer numbers memory representation</li>
<li> Floating point numbers memory representation</li>
</ol>

<p> I'll write few short notes about each.</p>

<h4>Getting familiar with the standard library</h4>

<ul>
<li>man stdio.h - ... or any other of the files for extra details</li>
<li>stdio.h - standard input/output: printf, getchar, fgets</li>
<li>limits.h - interesting constants including INT_MIN, UINT_MAX</li>
<li>strings.h - strlen and others</li>
<li>math.h - pow and others, interestingly no int arguments, mostly floats and doubles</li>
<li>stdlib.h - atoi converts string to integer </li>
</ul>

<h4>Endianness</h4>

<p> On Linux I can check the "endianness" or "the byte order" using <code>lscpu</code> in the terminal. Most systems use "Little Endian" which means that bytes are stored in reversed order. Literally the "most significant byte" is the last byte in the "word". Weird, I don't know why they did it. Here is a quote from Wikipedia page about endianess:</p>

<p> Computer memory consists of a sequence of storage cells (smallest addressable units), most commonly called bytes. Each byte is identified and accessed in hardware and software by its memory address. If the total number of bytes in memory is n, then addresses are enumerated from 0 to n − 1. Computer programs often use data structures of fields that may consist of more data than is stored in one byte. For the purpose of this article where its use as an operand of an instruction is relevant, a "field" consists of a consecutive sequence of bytes and represents a simple data value which – at least potentially – can be manipulated by one hardware instruction. The address of such a field is mostly the address of its first byte. In addition to that, it has to be of numeric type in some positional number system (mostly base 10 or base 2 – or base 256 in case of 8-bit bytes). In such a number system the "value" of a digit is determined not only by its value as a single digit, but also by the position it holds in the complete number, its "significance". These positions can be mapped to memory mainly in two ways:</p>

<ul>
<li>decreasing numeric significance with increasing memory addresses (or increasing time), known as big-endian and</li>
<li>increasing numeric significance with increasing memory addresses (or increasing time), known as little-endian.[note 3]</li>
</ul>

<h4>Integer numbers memory representation</h4>

<p> Apparently most CPU architectures don't represent signed integers with just a "sign bit + normal integer in binary". They use a thing called <a href="https://en.wikipedia.org/wiki/Two%27s_complement">"the two's complement"</a>. It's one of the three options provided by the <a href="https://web.archive.org/web/20181230041359if_/http://www.open-std.org/jtc1/sc22/wg14/www/abq/c17_updated_proposed_fdis.pdf">official C standard</a>: sigh/magnitude, one's complement, two's complement, and the last one is the most popular because it has some benefits comparing to the others. One of such benefits is that it is impossible to represent a negative 0, there is only a positive zero.</p>

<p> As a heuristic we can imagine that signed integer two's complement implementation represented on a axis will look like this 0,1,...,126,127,-128,-127,-126,...,-2,-1. So with all bits set to 0 we get 0, we all bits set to 1 we get -1, with the first half of bits set to 1 we get 127. And when the next bit is set to 1 the next number after 127 will be -128. It's a gotcha you need to keep in mind when manipulating integer bits manually.</p>

<h4>Floating point numbers memory representation</h4>

<p> Floats can represent extremely big or small numbers if you don't care about 100% accuracy. However they can't represent both at the same time. You can't have extremely large number with an extremely small fraction.</p>

<p> Floating points have very interesting implementation. I'm sure I could read all about the details in the <a href="https://web.archive.org/web/20181230041359if_/http://www.open-std.org/jtc1/sc22/wg14/www/abq/c17_updated_proposed_fdis.pdf">official C standard</a> but I don't need to know everything right away. </p>

<p> The <a href="https://evanw.github.io/float-toy/">Float Toy</a> helped me visualize and understand the architecture of floats. For now the following limited understanding should suffice.</p>

<p> Floats are represented in memory as a string of 32 or 64 bits composed of three memory segments: the signed/unsigned bit, the "exponent" (24 bits) and the "significand" (7 bits).</p>

<ul>
<li>The signed/unsigned bit represents if the whole value is negative or positive</li>
<li>The "exponent" is essentially functioning as a scaling factor. It's a signed integer that will be used as power of 2. So 2^n. 2 is sometimes called the "radix" and it usually has the value of 2. It looks like the exponent is using the same scheme ("the two's complement") used to represent integers.</li>
<li>The "significand" or significant digits, is a smaller unsigned value representing the "core" value that will be scaled by the exponents. From what I can see max value with all bits set to 1 represents 9.9999999, smallest possible values with all bits set to 0 represents 0 and each bit from left to right divides the number in half thus 10000000000000000000000 represents 0.5, 01000000000000000000000 represents 0.25 and so forth and 11000000000000000000000 is 0.5 + 0.25 = 0.75. Pretty neat.</li>
<li>It also looks like if any bit of "exponent" is set then the "significant value" is 1 + the fraction.</li>
</ul>

<p> Together "signed, significand * 2^exponent" can represent a great range of numbers and and naturally the bigger the number the less "resolution" can be represented - hence floating point. It's a very clever design.</p>

<p> It looks like x,y coordinates in 32 bit floats are not capable of representing the surface of the entire earth in meters. At the very end the values jump for 2 meters. Now, 64 bit floats are more then enough to have every micrometer of plant earth.</p>

<h3>Sat  1 Aug 23:51:00 CEST 2020</h3>

<p> I noticed that deleting all content of a file and then executing 'u' undo command generates another db error. After short investigation I found append() to be the reason. Nvi "logs" all changes to the open text document to be used later as history that can be traversed with "u" and ".". The append() function interanlly operates on the database. For some reason after deleting all contents in the file and then pressing "u" I get following error: "Error: unable to insert at line 0: BDB0063 DB_BUFFER_SMALL: User memory too small for return value". I suspect like with the previous bug I solved it's related to changing the Berkeley database version from 3 to 5. I downloaded the official documentation, and it's pretty extensive. I've read opinions that BDB is fairly easy in usage but it may be too much for me at the moment. I want to actually understand the problem and solve it properly and it will require of me to understand how BDB works and how to use it. I'm afraid it maybe be too much for me right now so I decided to temporarily go back to K&R until I feel more confident with C. </p>

<p> Also I just noticed the ampersand doesn't work in my blog tech. My AWK script thinks I'm trying to use a variable.</p>

<h3>Sat 25 Jul 14:40:36 CEST 2020</h3>

<p> I noticed today that my server is having higher amount of bandwidth usage then it should. Pretty much no one knows about it so I'd expect zero activity. but in July there was almost 0.5GB of data sent by my server. I checked out the nginx logs and it looks like I am being constantly scanned for vulnerabilities. That's pretty scary. Who knows about it? And why do they do this? I check few IPs: Russia, the Netherlands, Hong Kong, they are all over the place, obviously not using their laptops and networks directly. I have nothing of value on my server, i suspect this may be an automated scan. I'm just not sure where they learned about my domain. Anyway for now I just limited the requests to save on the server bandwidth.</p>

<h3>Tue 21 Jul 22:34:35 CEST 2020</h3>

<p> I fixed the db problem. It was simply a change in the db_open API in db5. It needs now DB_CREATE flag. Easy enough. After fixing this I discovered that the "catalog" code (probably UNIX name or name convention for internationalization) it was trying to load a file based on the LANG env var which obviously doesn't exist because I have removed the catalog directory completely. I disabled the catalog file loading with early return 1 in the loading function. I also left a TODO comment there to remember I need to clean it up since I won't be using it at all. If you are using vi-like program you can speak English, let's be reasonable.</p>

<h3>Sat  4 Jul 13:27:02 CEST 2020</h3>

<p> I updated the <a href="">read-me file in vip repo</a> recently, including a section with feature ideas. Next day I randomly stumbled upon <a href="https://opensource.apple.com/source/vi/vi-7/nvi/docs/features.auto.html">Apple's notes on features ideas for nvi</a>. That's a good source of inspirations for features. In general I'm surprised that apple has nvi source code and it my come in useful in more ways then one.</p>

<h3>Fri  3 Jul 00:14:54 CEST 2020</h3>

<p> I've finally finished removing all clutter from the vip's source code. From the original 612 files there are now only 172 files left. A whole lot less files to maintain and understand.</p>

<p> My recent effort in migrating the code-base from in-house regexp to the TRE library served me well as hoped. I started making changes in the actual code and got more confident with GDB and debugging. I feel I'm now ready to starting introducing new features. </p>

<p> Before that however, there are still few bugs to iron out which appeared after all that clutter removal. Most noticeable of which is the strange error about database each time I close vip. "BDB0635 DB_CREATE must be specified to create databases." it utters unashamed each time for goodbye. I suspect that's because Vip was using db3 before and now I made it use system's version which on my system is db5. Not a big deal, vip functions most of the time normally. Still that's the first bug to fix.</p>

<h3>Tue 30 Jun 23:18:48 CEST 2020</h3>

<p> Grand success! After few days of banging my head on the wide char and regexp search problem I decided to test it in isolation. I created a simple program with few lines of c built it with gcc myself - just a new, super small project to test things out. I quickly realized that TRE supports wide char charters but not via standard regcomp() and regexec() api, it has regwcomp() and regwexec()! That was the key! I was feeding wide character strings to normal regex functions and they were getting confused. So I have now a functioning wide char version of vi using TRE for regexes!</p>

<p> There is still the problem with missing support for REG_STARTEND which produces false positives in some lines and matches only the first occurrence in the line (so "n" command doesn't jump to the next occurrence in the same line) but I can emulate it with the idea I was talking about in the previous post. It's somewhat annoying but I can see now that's almost back to be 100% functioning.</p>

<h3>Wed 24 Jun 23:33:16 CEST 2020</h3>

<p> I managed to replace the glibc regex library with <a href="https://github.com/laurikari/tre">TRE</a>. There was only a single issue with compilation after replacing the library. The code-base is using non-POSIX REG_STARTEND regexec() flag. For now I just removed that flag. Other then that everything compiled flawlessly including the --enable-widechar compilation option.</p>

<p> The executable seems to function normally. I can enter and see correct wide characters including ą and ł. However the search feature seems to be off. It seems to be matching only the first word in a line. I suspect it has something to do with that REG_STARTEND I removed.</p>

<p> From what I could find out f_search() calls db_get() to load a line of text from the opened text file. As far as I can see db_get() copies the value of the line onto one of the arguments it receives without cleaning this argument first so lines often look like current line was just pasted on top of the last line. I presume that was done in the name of performance and is relaying on that REG_STARTEND flag.</p>

<p> I am not entirely sure but I suspect if I can emulate the REG_STARTEND behavior I can fix the search but it's a gamble - I am not 100% sure what is actually going on. Anyway the "cleverest" idea I had on how to emulate REG_STARTEND was to just clean the line variable so that regexec() is operating on a clean line each time.</p>

<h3>Tue 23 Jun 20:19:02 CEST 2020</h3>

<p> Yesterday it was really late when I was investigating f_search(). I realized that I saw in GDB a value for a string that was presented by GDB as L"some string" because it was a wide char string. It seems that nvi keeps all strings as wide characters when --enable-widechar compilation options is used. </p>

<p> I now think that f_search() or re_compile() or re_conv() or any other function is not the root cause of the problem. The problem is that all strings are wide, as in each character takes 16 bits while the regex expects 8 bits only, there is nothing I can do about it other then disable widechars therefor changing the memory alignment back to 8 bits per character like regex expects or change the regex library to one that supports wide character strings. Well I could also try to "flatten" the wide strings to normal strings just when they are fed to the regexec() function, but those kind of hacky solutions often tax you increasingly the further you go.</p>

<p> I'm not sure if disabling the wide chars is a viable options. Theoretically I could disable the wide chars and make the entire system operate on 8 bit strings while enabling wide char curses library so that it can still render wide characters correctly in the terminal. That seems plausible, however I'm not sure how will the system behave when moving cursor around a wide character. Assuming that this idea would work, lets say we have a string "hello Micha|ł" where | is the cursor. If I have 8 bit string and 16 bit curses library, what happens if I move the cursor one character to the right now? Have I moved 8 bit or 16 bit? And if I moved 8 bit is my cursor "inside" the "ł" from the perspective of curses library? That could prove problematic. However if this would just work, it would be the simplest solution, so it's still tempting to investigate it.</p>

<p> The other option is to replace the libc's regex library with some other "mostly compatible" library which supports wide characters. I say "mostly compatible" because I found out yesterday that nvi does some light processing on the regex pattern before compiling it in re_conv(). So whatever library I choose should have regex syntax similar enough so that I don't need to change re_conv() too much. I found following candidates:</p>

<ul>
<li>PCRE - perl's regex library, widely popular library and syntax, mostly super-set for libc's regex syntax</li>
<li>TRE - <a href="https://github.com/martanne/vis">vis editor</a> is using that under the hood</li>
<li>RE2 - a regex library from google, seems quite popular as well</li>
<li>Plan9's regexp - I heard good things about regexes in Plan9</li>
</ul>

<p> Also I noticed that TRE for Vis is optional and when not used Vis uses <regex.h> I wonder how they solved it. I heard that Vis uses musl instead of glibc. I just checked and musl's regexp is based on TRE, so it's possible that vis has wide char support either way because it uses directly or indirectly TRE.</p>

<h3>Tue 23 Jun 00:12:27 CEST 2020</h3>

<p> It seems like the search results in random positions even when there is no wide characters in searched file. Anyway I briefly checked out f_search(), internally executes regexec(). From what I found regexec does not support wide chars so that's potentially the issue but rather unlikely due to the symptom I mentioned above. But before it calls regexec() it does a bunch of initialization work: it calls search_init() which calls re_compile() which calls re_conv(). Apparently nvi translates for "vi regexp" to the POSIX regexp. I actually thought vi used POSIX regex syntax directly. And it pretty much does, this re_conv() function just supports the the magic characters and \<ptrn\> literal patterns (not sure what are those patterns atm).</p>

<h3>Sun 21 Jun 23:49:08 CEST 2020</h3>

<p> v_exaddr() eventuall calls f_search() too. Well not directly, v_exaddr() actually calls ex_range() which calls ex_line() which calls f_search(). Point is, all roads lead to f_search. I think my next step will be to investigate how f_search actually works and if it's broken with compile flag --enabled-widechar.</p>

<p> I figured out the above using GDB. GDB is kind of a complex program but it does have some really nice quality of life features built in which allow me to use it without first reading the extensive info gdb manual. The help command is amazing it lets me pretty much figure things out one the go.</p>

<p> Oh and I updated my homepage, I refreshed and used my old experimental project with react rendering 3D html billboards via CSS transformations using three-js for 3d perspective calculations. It's quite fun I can make gifs and text and emojis and everything else HTML can do in 3D spin around. I'm thinking I should capitalize on this technology and make my real homepage based on that. It's visually quite impressive for uninitiated and technically interesting since it intentionally avoids webgl (thus can exploit all rendering capacities of standard HTML browser renderer).</p>

<h3>Sat 20 Jun 14:30:53 CEST 2020</h3>

<p> I finally decided to start hosting my own website. An idea I was toying with for decade and a half. Turns out system administration is a whole lot easier when you poses fundamental competence with unix-like shell.</p>

<ul>
<li><a href="https://michalradecki.com/blog.html">https://michalradecki.com/blog.html</a> is the new home for my blog.</li>
<li>For the time being I'll still support <a href="https://pyzozord.github.io/blog/">https://pyzozord.github.io/blog/</a> but I think I'll drop it eventually.</li>
</ul>

<p> Since we are nowhere near the subject I want to take this opportunity to remind myself of the following distinction. Why not, my blog, my rules.</p>

<ul>
<li>"command line" - Is a way to describe computer interface which operates only on text entered commands</li>
<li>"shell" - Is a part of unix architecture for command line</li>
<li>"terminal" - Those were old computer devices earlier models reassembled typewriters, later models had CRT screens</li>
<li>"terminal emulator" - Is computer software emulating a terminal device connected to a shell</li>
</ul>

<h3>Wed 17 Jun 21:52:38 CEST 2020</h3>

<p> I noticed that the same searching bug happens in both vi and ex modes, if the authors of nvi had any kind of common sense there is probably a piece of code uses by both vi and ex that performs the actual search. Open source developers are generally really skilled so I think it's safe to assume that.</p>

<p> I noticed in that vi actually uses ex's address routines for its search feature. All functions in /vi/v_search.c eventually directly or indirectly call v_exaddr(). I'm pretty sure what I am looking for is not in the /vi/ directory.</p>

<p> Not all of the /vi/v_search.c functions actually lead to v_exaddr(). Some lead to f_search() and b_search(), those two are defined in /common/search.c that's another potential candidate.</p>

<h3>Sat 13 Jun 23:59:45 CEST 2020</h3>

<p> Removing /regex is more difficult then I hoped. The autoconf script has --disable-re flag which basically makes the build ignore all code in /regex and link to system's regex.h instead which is great. However after it builds without too much complaining (single use of one non-standard flag REG_NOSPEC) the resulting binary behaves strange. Ctrl+a command results in "RE error: Invalid character class name". </p>

<p> But that's not all, the biggest problem is when I use another autoconf script flag --enable-widechar. When I don't use that option I can't type in polish characters example for "polish a": "ą". And if I do use --enable-widechar I can type "polish a" normally "ą", but the / search feature yields random results it matches arbitrary places in the file.</p>

<p> I don't exactly understand why the regex library bundled with nvi source works properly and the gnu regex library does not. From what I found out both POSIX's and GNU clib's regcomp() don't support wide character strings. I couldn't find any information on BSD's regcomp(). Does it support widechars? If it doesn't what makes it work properly while gnu's doesn't?</p>

<p> I don't really know what I am talking about or how characters are really actually handled in C. I know that standard ASCII and POSIX characters are 8 bit (actually 7 bit, last bit is not used) and therefor can encode English alphanumerics and few extra symbols. UTF8 is what's called "variable length encoding" which means that most common characters are encoded in 1 byte like ASCII less common characters in 2 bytes and so on up to 4 bytes. There are also "widechar" strings in C which seems to be a different name for UTF16 which is kind of like UTF8, also "variable length" however it consists of one or two 16 bit codes (as opposed to UTF8's one up to four 8 bit codes). </p>

<h3>Wed 10 Jun 23:10:16 CEST 2020</h3>

<p> My <a href="https://github.com/pyzozord/vip">nvi fork project</a> is making steady progress. I decided to name it VIP, I'm quite enjoying all the potential expansions of the acronym. Vi by Pyzozord (my IRC nickname), Very Important Program, VI with Plugins, VI Perfected. The possibilities are endless.</p>

<p> Anyway I managed to remove even more stuff: catalog - responsible for translations, clib - no need to support environments who don't have full c library, db - no need to maintain source for that, instead I'm using now libdb and ip/ipc - no need to worry about inter process communication for now, I have a specific idea for how I want the plugin system to work.</p>

<p> Hopefully I can remove regexp, ideally I don't want to maintain regular expression engine and just link statically a regexp library available on the system.</p>

<p> Can't wait to the moment I'll start writing features for this thing. Not sure what the first feature should be. Something helloworld-y, something just to get me started. Maybe just modification for the visual bell, the full screen flash is quite obtrusive.</p>

<p> In fact I'm actually writing this post in the latest build of vip, there is virtually no difference what so ever comparing to the normal nvi.</p>

<p> After vip will be usable enough, the next step will be to make my own terminal emulator. I want something extremely simple. But I do want media playback in the background. I want my terminal to be able to display images and videos in the background and adjust solid color overlay so foreground text is still readable. I'm eyeballing the <a href="http://st.suckless.org">suckless terminal</a>. It's based on Xorg but maybe I could migrate it to SDL so that I can compile it on mac? It's quite great, really lean code, still well supported and plenty of extra features I can add via code patches.</p>

<p> Writing code in my own code editor inside my own terminal emulator... Finally at peace.</p>

<p> Can't wait for those looks in the eyes of colleagues who asked "What terminal are you using?" or "Your Vi looks quite strange, how did you do that?".</p>

<h3>Sun 24 May 15:52:27 CEST 2020</h3>

<p> Since Friday I've been reading the <a href="https://repo.or.cz/nvi.git">nvi repo</a>. I decided writing my own editor in c is the best way to refresh my c-fu. It's been quite educative and definitely a history lesson of open source software development. I've cloned it and started removing features I'm not interested in like perl/tcl support or gtk/motif versions. </p>

<p> I'm very excited. Vim is too much. It took me a decade to get familiar with it and I still don't know more then a half of it. Ed is too simplistic, support for auto indentation is a must in 2020, same with tab/space indentation conversion. Vi is almost perfect, but I still miss some quality of life features from vim. I think the perfect editor for me is somewhere between vi and vim. </p>

<p> I also have my own ideas on how to improve it. </p>

<p> I want to implement Plan9's Structural Regular Expressions like they did in <a href="https://github.com/martanne/vis">vis</a>. Also I had some ideas about a new mode for vi editor which also operates on objects and motions but they are ast objects and motions instead of word objects and motions. And finally I'd like to have scripting support for any and all languages. </p>

<p> I don't want to have built in interpreter for perl or lua or nodejs. Instead I'd like to leverage posix process communication (maybe pipes?) so that users can write scripts in any and all languages they like extremely easily. If you want to add a new word object you can do it in a simple php program which just uses standard input and output to communicate with VIP. Or any other language for that matter. Or add entirely new editing mode. I want the scripting to be based on standard basic posix features, extremely easy to implement (so that a developer with less then 6 months of experience could extend VIP however they want) and extremely powerful (so that scripting can change virtually any aspect of how Vip works). Lofty dreams I know.</p>

<p> <a href="https://github.com/pyzozord/vip">https://github.com/pyzozord/vip</a></p>

<h3>Mon  4 May 12:18:35 CEST 2020</h3>

<p> My interest are in few things and those things seem to naturally intertwine and connect with each other in a complex, folded many times over manner. Every time I learn something new	on the edge of my area of interest I discover entirely new locus of meaning which connects in new, surprising and complex ways with the existing body of knowledge making the entire model even more convoluted. I developed an interest in systems via programming. There are many different systems at different levels. On other such system is social dynamics in professional context. And generally in any context. Recently I came across the Gervais Principle. It's an amazing, engineering model of social dynamics of commercial organizations. </p>

<p> <a href="https://www.ribbonfarm.com/the-gervais-principle/">https://www.ribbonfarm.com/the-gervais-principle/</a></p>

<p> I am in shock. It made me understand so many before inexplicable evenest I have experienced. I was intuitively half aware of some small portion of this model, but having it all laid out like that clearly and comprehensively opens my eyes. At first I was furious. I felt cheated like a complete idiot. I was the Clueless. I have now wide open maneuvering field. I just need to decide what I want. (This last part may be more difficult then it sounds)</p>

<h4>Tue Mar  3 21:42:30 CET 2020</h4>

<p> I've been spending some time exploring OpenBSD, pretty cool stuff. I am thinking about migrating to OpenBSD full time. I think I'm naturally aligned with the philosophy behind it. From my experience a well fit symbiosis like this brings unexpected desirable results. Things just click together in places one wouldn't expect.</p>

<p> I've been also migrating from Vim to Vi. I had a brief episode with Ed but quickly discovered I do need a little more then that (auto indentation was the thing that pushed me over the edge). So now I'm on Ex and the Vi. I first started with Ex-Vi (the traditional ex and vi) but today I moved on to the little cleaned up and just a bit bigger Nvi. Nvi is fully "bug-to-bug" compatible with ex-vi, but has got few extra features. It's also the default version of vi on BSD systems including OpenBSD.</p>

<p> Lastly I made more progress with my genetic algorithm. I further improved the graph visualization. First of all I ordered each individual in a generation from highest to lowest fitness. When the graph displays all generations it's now easily visible how one outstanding individual in generation X breeds into 90% of the population X+3. This help me understand <em>why</em> is my algorithm not finishing. I believe that my populations become to monotonous, having mostly identical DNA. I am thinking now about improving the breeding processes from random to a weighted random. Individuals will prefer other individuals with fitness's that complement theirs as breeding partners. This is pretty exciting, it may be the solution! And I haven't even got to counting schemata. I think if I'm lucky enough I may not have to implement counting schemata for breeding preference, very simple difference in finesses may be enough!</p>

<h4>Sat Feb 22 15:12:15 CET 2020</h4>

<p> I was finally done with the research for spatial partitioning and decided to share it on <a href="https://www.reddit.com/r/roguelikedev/comments/f4ouh5/infinite_game_worlds_and_spatial_data_structures/">rouglikedev reddit</a>. It got quite popular and sparked some interesting conversations. Anyway I'm a little tired with this subject for the moment and the article was finally done.</p>

<p> I started thinking about new project. And decided to come back to my genetic algorithm week planner. I was maintaining that project for more or less half year without developing any new features. Just cleaning up the code and updating the dependencies from time to time. Today I spent a moment adding a click debug feature displaying information about each clicked individual on the graph. And that lead me to a small breakthrough. The algorithm wasn't performing well because it was selecting random individuals for breeding. My fitness sorting function was incorrect. Fixing the sorting fixed the selection which in turn fixed the breeding and suddenly everything fell into place. Now it's performing quite well. It is still stuck in local maximum after few generations but it is now very close to solving the weekly schedule. I am happy with this. My next step is to start plotting different variables like total generation fitness over time and maybe some other things that would give me more insight and help debug why it's stuck in the local maximum.</p>

<p> Oh I also made the smallest but coolest quality of life improvement to my bash setup.</p>

<p> <code></code><code> function tree() {   find ${@-./*} | sed -E 's:[^/]+/: :g' } </code><code></code></p>

<p> This is my home brew replacement for the popular <code>tree</code> cli tool. I'm working on mac so I don't have it available to me out of the box and I really hate the idea of installing third party tool if I can use the tools available to me already to solve the problem. </p>

<p> Together with the <code>scout</code> (tool giving a birds eye overview of the biggest directories I made few months earlier) and all of POSIX (mostly <code>find</code> and <code>grep</code>) they make great tools at exploring new code bases and directories.</p>

<p> <code></code><code> function scout() {   for F in ${@-./*}; do echo "$(find $F | wc -l) $F"; done | sort -r } </code><code></code></p>

<p> Ugh, I see need to fix my blog markdown parser so it doesn't mess with code blocks or inside HTML tags.</p>

<h4>Space Partitioning - Sun Feb 16 10:03:46 CET 2020</h4>

<p> I've been thinking a bit more recently about infinite game worlds and rogue-like games. I found a very interesting free book http://gameprogrammingpatterns.com/. It has a chapter about spatial partitioning which is exactly what I was interested in. Unfortunately that chapter is very fundamental and does not answer my question. It did give me few ideas though.</p>

<p> My goal would be to have an infinitely big, persistent world. The game would not have to simulate every single agent in the entire world on every game loop tick. That would be silly. It would simulate only the agents within the view of the player. All other agents instead of being simulated separately would be rather kind of reduced to a "heat map of probabilities" in a similar way GTA or SimCity games do with cellular automata layers. But even in that case there would be static objects which don't require processing every tick but do require being remembered separately. For example if I'd kill a deer and then left that area to gather wood for a bonfire, I would expect the deer's corpse to still be there when I return.</p>

<p> I can imagine a simple 1 dimensional array with a list of all objects in the world. Such a list would be really long so I would be able to load only chunks of it at a time. How do I know which chunks to load? I should load only relevant chunks so once that are near the player or in the player's view.  Well if I care about the chunks of the list of game objects in a spatial sense (only chunks <em>close to</em> the player) than I should assign some spatial information to those chunks (aka index them). All fine so far, lets say our chunks are laid out on a grid of 16x16 "meters" and each chunk can hold any number of objects. Not ideal for very densely populated areas but let's ignore this problem for now and continue.</p>

<p> Knowing chunk's size and x, y coordinates of the chunk I want I can easily calculate the position of that chunk in the file and load it into memory. Great! Eureka! I can go home. But what if usually there will be big number of chunks processed at once? I'd need to do IO file operation for many of the chunks I want to load. Is there any way I could pack and order those chunks in a file to minimize IO operations when reading them? </p>

<p> From a simple calculation we can guesstimate how long an average IO operation takes on a HDD. Lets assume a 7200 RPM HDD (120 RPS) with average seek time 8ms. RPM stands for "revolutions per minute" or simply rotations per minute. To read data from a spinning disk HDD has to move the head (the needle) to the right position and then wait up to 1 full rotation. Ignoring time for the CPU overhead we can say that 8ms seek + rotational latency (1s / 120rps = ~8ms) is 16ms for a single read. Simply reading a big file in continuous fashion will generate multiple IO operations. Naturally seeking to neighbor tracks will be much faster than changing a cylinder and our guesstimate is generally really rough. But for our purposes knowing the order of magnitude should be enough. You can read more here https://en.wikipedia.org/wiki/Hard_disk_drive_performance_characteristics.</p>

<p> I looked into few different ideas on how to index and encode the chunks on Wikipedia https://en.wikipedia.org/wiki/Spatial_database#Spatial_index and that game programming book http://gameprogrammingpatterns.com/spatial-partition.html.</p>

<p> https://sites.cs.ucsb.edu/~suri/psdir/ASP.pdf</p>

<p> <strong>Binary Trees</strong> While thinking about ways I could encode the coordinates in a file I arrived at Binary Trees. Not exactly a spatial data structure. Rather a fundamental computer data structure. Idea is simple a set of values is recursively divided into two subsets. Left set holds values smaller then the division point, right set holds values bigger then the division point. Only leaf nodes (nodes without children) of the tree hold actual position. There is many different permutations of that idea and there are many different considerations. Balancing the tree is often one of the big concerns.</p>

<p> <strong>B-Trees</strong></p>

<p> After Binary Trees I skipped over the binary heaps, binomial heaps and priority queues. Then I found B-Trees (https://queue.acm.org/detail.cfm?id=1814327). Simply put, B-Trees are a lot like Binary Trees but can have <em>m</em> max children (rather then 2) and are designed such that really large trees can be kept in storage and only part of the tree is loaded to memory at any moment. Similar indexes are paged in and out of memory together. That minimizes the amount of memory (and IO) operations For some reason I got inspired to check if MySQL uses B-trees, and it does. Then I saw that MySQL uses R-Trees for spatial indexes. Then my head started spinning, I'm in over my head.</p>

<p> <strong>Grid</strong></p>

<p> But first Grid. Grid is the simplest solution to my problem. Divide the world into equal size chunks with X and Y coordinates. Keep each chunk saved as a separate file is enough. Since this project is educational for me and I want to wet my feet in a bit in algorithms and data structures and the techniques similar to those used in the 3D engines I decided I still want to implement something more complex. To make it more challenging I decided I want my game to also support polygons. In case of grid it's quite easy to just cut the polygons at the chunk edges.</p>

<p> <strong>Space filling curves</strong></p>

<p> Space filling curves like Hilbert Curve are very interest and simple. It would certainly help save the chunks in a file in a more "stream-able" fashion since the Hilbert curve makes the file bit stream more chunky and area like instead of having a continuous horizontal line of the entire world. It would probably decrease amount of IO needed to load the right chunks from the memory.</p>

<p> <strong>BSP Trees</strong></p>

<p> Binary Space Partitioning Trees are famous. They were used in the 90s for most of the 3D games, most notably Doom. It recursively subdivides the space into two convex spaces using hyperplanes as partitions.</p>

<p> <strong>Quad trees</strong></p>

<p> Next are quad trees. I know quad trees or more specifically octrees are commonly used in the 3D video game industry. If I'm not mistaken leading occlusion culling software Umbra3D (used by such games as DOOM 2016 or Witcher 3) uses octrees as foundation for their algorithm. My first thought about quad trees is that they share a lot with the Hilbert curve. It seems like a quad tree could be encoded using Hilbert curve. Quad trees are also a special case of a BSP Tree.</p>

<p> <strong>K-d tree</strong></p>

<p> Another binary tree. This one is k-dimensional. It's actually another special case of a BSP Tree. Each leaf of the tree is a point that implicitly splits the space into two so called "half-spaces". K-d trees are used in ray tracing probably because they are very efficient at queries but they are too slow for real time manipulations, building and rebuilding takes too long.</p>

<p> <strong>R-trees</strong></p>

<p> Wikipedia entry on r-trees is promising. They have native support for polygons and were specifically design for large data sets that cannot be kept entirely in memory and have to be paged in and out of ram from disk. seems like r-trees generally have faster lookups and quad trees are faster to build, interesting trade off. Another interesting fact about r-trees is that they use MBR (minimal bounding rectangles) which means I can have the top level of the tree spanning entire galaxy and immediate next level really small for example 16 square meters. That means no unnecessary subdivisions and index tree branches in a galaxy where only fraction of one percent has been generated.</p>

<p> <strong>Geo hash</strong></p>

<p> Geo hash approach seems very similar to the Grid but it has few interesting properties on it's own. Geo hash has a single hash code value, not a coordinate pair like the Grid. Arbitrary precision of coordinates and gradual loss of precising while removing characters from the end of the hash code could come in useful. This also results with places nearby presenting similar hash code prefix. This naturally leads to indexing the hashes, B-Tree would be ideal. The hash code itself is a base 32 encoded interleaved pair of binary indexes for coordinates. Pretty smart.</p>

<p> Honestly half way through this research I got bored with it and with making a rogue-like anyway. If I'd follow through I'd probably go for a combination of Geo hash, Grid and Hilbert Curve. Geo hash would allow arbitrary sizes, allowing entire galaxy of meters. Grid is the simple partitioning algorithm and can be encoded directly in rehash and Hilbert Curve is a nice packing algorithm to order grid cells and save on disk to be streamed to memory later.</p>

<p> I am really happy I did this research, I've learned a decent chunk of algorithms and data structures and feel much more confident now about my understanding how games organize space and implement open worlds.</p>

<h4>Tue Feb  4 00:58:57 CET 2020</h4>

<p> Another quick update. I just felt inspired and decided to add HTML template to my blog so I can make shorter lines and longer line spacing. Looks much better now! Also fixed the post ordering so post 10 doesn't show immediately after post 1 but rather after post 1. And reversed the order so the latest post is at the top.</p>

<p> P.S. still working on that entry about spatial partitioning.</p>

<h4>Sun Feb  2 11:15:42 CET 2020</h4>

<p> A quick update. I'm currently ill with the seasonal virus and flu and have a bit more time. I've made small updates to my blog engine (fixed entry length to from 15 lines to infinite and improved handling of <code>_emphasis_</code> text). Since few days I'm working on a longer post about infinite game worlds and space partitioning, it should be out next week. Meantime something else I feel I need to share.</p>

<p> Yesterday I've discovered a fascinating and profound talk by Alan Kay https://www.youtube.com/watch?v=j9ZGFaIHegE. (Here is the pre-read https://internetat50.com/references/Kay_How.pdf.) Alan Kay has been working in ARPA and Xerox research facilities and had a lot to do with invention of only such small technologies as personal computers, graphical user interfaces, object oriented programing and the internet. If Alan Turing is the Newton of Computer Science, Alan Kay is the Einstein (he also looks like one in the video). It's amazing how profound that talk is. Every single minute hits home and has deep meaning. It almost feel like everything I've been studying over the last year has been in preparation to receive this talk. Whenever I feel I learn something profound and deeply meaningful I feel pleasurable feeling of excitement, a wave of tingling passes through my body. This was definitely one of those times. It could be the confirmation bias, but it felt great to know that my instinctive curiosity is leading me to the areas such great minds as Alan Kay are dwelling.</p>

<h4>Paying And Incuring Debts - Tue Jan 14 19:44:18 CET 2020</h4>

<p> My hackathon project turned out to be a grand success and turned out exactly the way I anticipated. Actually no, it surprised me how fast things have started moving and how far the cascading effects reached into areas I did not at all had foreseen in the most wonderful way. I believe my work has brought joy and promise of better future to many people, including myself. Currently I'm again resting from deeper dives into technology. I'll need to pay my debt and follow up on that hackathon migration success with similar successes for many other features in our monolith application. I've been whining all year about what I wanted. Now I got it and it's time to shut up and pay back the favor.</p>

<p> I'm using the downtime to decompress, refocus more on my personal mental and physical wellness. "Health" would have sounded wrong here since I do consider myself quite healthy at the moment, certainly not any less healthy then an average person of my circumstances. I focused on eating less and better things, I'm shyly trying my way back to some exercising and spending more time reading Nassim Taleb and Nietzsche. I also rediscovered the amazing joy of doing something selfless. Indeed Taleb is right about the Skin In The Game. But having skin in the game for a selfless cause feels almost ubermensch-ish... It definitely let me straighten up my back, rise my head and feel like I have right to be on this planet. But again it's critical I follow this promise of selflessness through and pay the debts. Not because how others see me. Because how I see myself.</p>

<p> PS. I noticed my posts are getting longer and less frequent. That was not the initial intention for this blog. I wanted to keep it more as a research log. I'll observe how it evolves for a while and then decide what to do about it.</p>

<h4>Sun Dec 22 21:46:17 CET 2019</h4>

<p> Recently I've been thinking more about computer graphics. Specifically about the 3D projection matrix and the occlusion culling techniques (based on BSP and octrees). I just found this awesome website with exhaustive and well explained 3D fundamentals https://www.scratchapixel.com/ (no occlusion culling though). </p>

<p> Did I mention I'd love to make a living owning a bike repair shop while making indie games? I don't have a thing for bikes, but they represent to me a different, slower kind of life. I'm 28 and even though I get bored with games much faster now and usually have enough after a one hour play session I still have in me 2 consecutive three hour play sessions every now and then. Not to mention how much actual time I spend consuming gaming content on youtube and the web (I should read more https://www.gamasutra.com/ though). I believe games are my biggest passion in life. There is something about the immersive escapism and world building that truly appeals to me.</p>

<h4>Sun Dec 15 20:33:26 CET 2019</h4>

<p> I've been busy with the hackathon held by my employer for the last few days so I couldn't really spend any time on personal projects. I managed to prepare PoC that it is possible to separate one of the major functionalities in our project into a separate project. This will decouple two teams and let each team has their own repository. I don't think I have to explain how far reaching positive effects this may have. It's a big win for me, my team, the other team and company in general. I hope I can follow up on this project afterwards and make the PoC into reality. Anyhow I feel pretty tired and bored with programming at the moment. Especially writing POSIX compliant scripts using sh, find, grep, sed and awk is quite difficult. I find POSIX versions of those utilities are really bare bones and often lack quality of life features. You can usually substitute those lacking features with just more scripts but in the heat of the moment like during a hackathon this can mean life or death. I imagine if I'd strictly stick with POSIX I'd build up a library of those convenience functions, but it will take time.</p>

<h4>Tue Dec 10 23:31:16 CET 2019</h4>

<p> I added awk pages to the blog. Right now this page is generated from multiple .md files concatenated by one <code>index.awk</code> file and all of it outputs as single <code>index.md</code>. I also added simple tempting system.</p>

<h4>Mon Dec  9 22:39:51 CET 2019</h4>

<p> I've solve it! I have now variables working in blog tech. Apparently my problem was that xargs was treating everything as one big argument instead of few separate arguments separated -v. I think internally xargs is not calling shell but rather forks the program directly and passes arguments to it via the c interface. That would explain why the command that was generated by <code>xargs -t</code> was working correctly when manually copied and pasted into the terminal but would fail when run via xargs/make. Anyway next problem to solve in blog tech is start dynamically replace variable names from .md files into their values that were passed as arguments to awk script.</p>

<h4>Mon Dec  9 19:49:35 CET 2019</h4>

<p> I'm a little tired of <code>make</code> and <code>awk</code> at the moment so I decided to switch projects for a while. I have the template variables feature pretty much working except that for some reason when running <code>awk</code> via <code>make</code> it errors with <code>awk: invalid -v option</code> but that same exact command when run manually by pasting it in the terminal work perfectly fine. I've recently heard that the "health" niche is evergreen on mobile. For the last year on and off I've been working on week organizer algorithm I named GYST. I'll brush up on this project. Update all the dependencies and see if I can make some progress. Last time I stopped at having simple D3 visualization for my genetic algorithm since I needed to understand better why doesn't my algorithm work.</p>

<h4>Wed Dec  4 23:49:47 CET 2019</h4>

<p> No time for updates. That unfortunately means no serious progress in the blog tech. I only improved the <code>make deploy</code> so that it commit file delete changes. It had a bug where it would commit previous file again even if it was deleted in the new version.</p>

<h4>Hello world - Wed Dec  4 00:49:05 CET 2019</h4>

<p> This is the first entry. I made today significant progress with my blog tech.</p>

<ul>
<li><code>make deploy</code> prepares a new <code>gh-pages</code> branch commit and pushes it to GitHub</li>
<li><code>awk/lib.awk</code> will be a common place for all shared AWK functions</li>
<li><code>make build</code> supports now parsing markdown meta variables (disabled until useful)</li>
<li><code>make test</code> runs <code>make build</code> and automatically opens the browser. Super convenient especially when running <code>:!make test</code> in vim.</li>
</ul>

<p> I'm very happy with this but it's 1am and I really need to get some rest.   </body> </html></p>

